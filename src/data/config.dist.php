<?php
namespace Zenya\Api;

// Define the DEBUG constant.
#Define('DEBUG', isset($_REQUEST['_debug']) ? $_REQUEST['_debug'] : false,
if(!defined('DEBUG')) define('DEBUG', true);

$c = array(

    // The API version string allowing users to keep track of API changes.
    // It is defined as major.minor.maintenance[.build]]:
    // - Major: increase for each changes that may affect (e.g. not be compatible with) a previous generation.
    //          Generally, would imply a fresh new deployment (.
    // - Minor: increases each time there are new resource entity being added to the API.
    // - Maintenance: increases each time there are moficiation to existing resources.
    // - Build: can be use for arbitrary naming such as 0.1.0.beta, 0.1.1.rc3 (third release candidate), 0.1.2.smoking-puma 
    'api_version'       => '0.1.0.empty-dumpty',

    // The API realm name. Used in few places, most notably as part of the version string in the header response.
    // It is also used as part of some authentication mechanisms e.g. Basic and Digest.
    // Should always be a generic/static string and cannot be used to define server instance.
    // In other words, DO NOT use $_SERVER['SERVER_NAME'] to set this option!
    'api_realm'         => 'api.zenya.com',

    // Define the name of the data output topmost node which contains the various nodes generated by the response output.
    // The signature and debug nodes (may) also live within that node if enable further down below.
    'output_rootNode'   => 'zenya',

    // Wether or not to output the entity signatures within the response-body. This might be useful to some clients/users.
    // Could also be made optional using a request variable as shown below:
    // 'output_sign'       => isset($_REQUEST['_sign']) ? $_REQUEST['_sign'] : false,
    'output_sign'       => true,
    
    // Wether or not to output the debugging in the response-body. Should be set to false on production servers.
    // Beware this settign affects page cachability.
    'output_debug'      => DEBUG,

    // The array of available data formats for input representation:
    // - POST:  Body post data. 
    // - JSON:  Light text-based open standard designed for human-readable data interchange. 
    // - XML:   Generic and standard markup language (defined by XML 1.0 specification). Currently only supporting UTF-8.
    'input_formats'     => array('post', 'json', 'xml'),

    // routing definitions
    'routing'           => array(

        // The regular expression representing the path prefix from the Request-Uri. Allows notably to retrieve
        // the path without the route prefix, handling variation in version numbering, Apache's mod_rewrite, etc...
        // Should match somethign like '/index.php/api/v1/entity/name?whatver...' which using mod_rewrite could
        // then translates into 'http://api.zenya.com/v1/entity/name?whatver...'.
        'path_prefix'       => '/^(\/\w+\.\w+)?(\/api)?\/v(\d+)/i',

        // The array of available data formats for output representation:
        // - JSON:  Light text-based open standard designed for human-readable data interchange. 
        // - XML:   Generic and standard markup language (defined by XML 1.0 specification).
        //          Later, other schema could be implemented if required.
        // - JSONP: Output JSON embeded within a javascript callback. Javascript clients can set the callback name using
        //          the GET/POST variable named 'callback' or default to the 'output_rootNode' value set above.
        // - HTML:  Might eventually be useful for white labeling purposes using some headers/footers templates, CSS...
        // - PHP:   Does not currently serialize the data as one would expect but just dump the output array for now.
        'formats'           => array('json', 'xml', 'jsonp', 'html', 'php'),

        // Set the defaut output format to either JSON or XML.
        // Note that JSON encoding is by definition UTF-8 only.
        // If a specific encoding is required then XML should be used as the default format. In most cases, JSON is favored.
        'default_format'    => 'json',
        
        // Use to enable the output format negociation mechanism from an HTTP accept header.
        // This is the expected and most RESTful way to set the output format.
        'http_accept'       => true,
        
        // Allows the format to be set in the Request-Uri.
        // e.g. GET /controler.json/param
        // Thi is handy and common practice but fairly un-RESTful...
        'controller_ext'    => true,

        // Forces the output format to the string provided and overrides the format negotiation process. Set to false to disable.
        // Can be use to set the format from a request parameter, or any other arbitrary methods, etc... 
        // Using REQUEST is considered un-RESTful but can be handy in certain cases (.e.g. forms).
        'format_override'   => isset($_REQUEST['_format']) ? $_REQUEST['_format'] : false,
    ),

    // Init is an associative array of specific PHP directives.
    // They are recommended settings for most generic REST API server and should be set as required. 
    // There is most probably a performance penalty setting most of these at runtime so it is recommneded that
    // most of these (if not all) be set directly in PHP.ini/vhost file on productions servers -- and then commented out.
    // TODO: comparaison benchmark!?
    'init'          => array(
        // Wheter to display errors (should be set to false in production)
        'display_errors'            => DEBUG,

        // Enable or disable php error logging
        'init_log_errors'           => true,

        // Path to the error log file
        'error_log'                 => '/tmp/zenya-errors.log',

        // Enable or disable html_errors
        'html_errors'               => false,

        /////////////////////////////////////////////////////////////////////
        // Anything below should be set in PHP.ini on productions servers. //
        /////////////////////////////////////////////////////////////////////

        // Whether to transparently compress outputs using GZIP.
        // Once enable, this will also add a 'Vary: Accept-Encoding' header.
        'zlib.output_compression'   => true,

        // Maximum amount of memory a script may consume.
        'memory_limit'              => '64M',

        // The timeout in seconds.
        // BEWARE web servers such as Apache have also their own timout settings that may interfer.
        // See your web server documentation for specific details.
        'max_execution_time'        => 15,

        ////////////////////////////////////////////////////////////////////////
        // These below might not always get set depending on the environment. //
        // Consider setting these in PHP.ini on productions servers...        //
        ////////////////////////////////////////////////////////////////////////

        // Maximum amount of time each script may spend parsing request data.
        'post_max_size'             => '8M',

        // Maximum amount of time each script may spend parsing request data.
        'max_input_time'            => 30,

        // Maximum amount of GET/POST input variables.
        'max_input_vars'            => 100,

        // Maximum input variable nesting level.
        'max_input_nesting_level'   => 64,

        // Determines which super global are registered an in which order variables are populated.
        'variables_order'           => 'GPS',
        'request_order'             => 'GP',

    )

);

// Service definitions
$c['services'] = array(
    'users' => function()
    {
        static $i = 0;

        // TODO: retrieve the users from somewhere, caching strategy?
        $users = array(
            // username:realm:sharedSecret:role
            0=>array('username'=>'franck', 'test_i' => ++$i, 'password'=>'123', 'realm'=>'api.zenya.com', 'sharedSecret'=>'apiKey', 'role'=>'admin'),
            1=>array('username'=>'bob', 'password'=>'123', 'realm'=>'api.zenya.com', 'sharedSecret'=>'sesame', 'role'=>'guest')
        );

        return $users;
    }
);

// Resources class definitions
$c['resources'] = array(

    // '/:controller/:param1/:param2' => array(
    //     'controller' => array(
    //         'name' => 'namespace\classname',                 # string
    //         'args' => array('classArg1' => 'test1', ...)     # array|null
    //     )
    // ),

/*
    '/keywords/:keyword' => array(
        'controller' => array(
            'name' => 'Zenya\Api\Fixtures\BlankResource',
            'args' => array('arg1'=>'value1', 'arg2'=>'string')
        )
    ),
 */
/*

    '/auth/:param1' => array(
        'controller' => array(
            'name' => 'Zenya\Api\Fixtures\AuthResource',
            'args' => array('arg1'=>'value1', 'arg2'=>'string')
        )
    ),

    '/upload/:type/:debug' => array(
        'controller' => array(
            'name'  => 'Zenya\Api\Fixtures\UploadResource',
            'args'  => null,
        )
    ),
 */

    // '/' => array(
    //     'controller' => array(
    //         'name' => 'namespace\classname',
    //         'args' => null
    //     )
    // ),

    '/help/:path' => array(
        'redirect' => 'help',
    ),

    '/*' => array(
        'redirect' => 'help',
    ),

    // '/test/:resource/:http_method/:filters' => array(
    //     'redirect' => 'test',
    // ),

);

// Plugins listener definitions
$c['listeners'] = array(
    'entity' => array(

        // fires early @ resource discovery stage
        'early_off' => array(
            // Basic Auth
            function() use ($c) {
                $adapter = new Listener\Auth\Basic($c['api_realm']);
                $adapter->setToken = function(array $basic) use ($c, $adapter) {
                    $users = Services::get('users');
                    foreach ($users as $user) {
                        if (
                            $user['username'] == $basic['username']
                            && $user['sharedSecret'] == $basic['password']
) {
                            return $adapter->token = true;
                        }
                    }
                    $adapter->token = false;
                };

                return new Listener\Auth($adapter);
            },
        ),

       // fires early @ resource discovery stage
        'early' => array(
            // Digest Auth
            function() use ($c) {
                $adapter = new Listener\Auth\Digest($c['api_realm']);
                $adapter->setToken = function(array $digest) use ($c, $adapter) {

                    $users = Config::getInstance()->getServices('users');

                    foreach ($users as $user) {
                        if (// this should be altered accordingly!
                            $user['username'] == $digest['username']
                            && $user['realm'] == $c['api_realm']
) {
                            // Can be set to password, apiKey, or hashed mixture...
                            return $adapter->token = $user['sharedSecret'];
                        }
                    }
                    $adapter->token = false;
                };

                return new Listener\Auth($adapter);
            },
            //'Zenya\Api\Listener\BodyData',
        ),

        'late' => array()
    )
);

/* Prototype:

function onRead($route, $call)
{
// add route to config route
// add call to resources.
}

    $c->onRead('/auth/:param1', function($param1) {
        new Zenya\Api\Fixtures\AuthResource($param1);

        return array();
    });

    $c->onCreate('/auth/:param1', function() {
        new Zenya\Api\Fixtures\AuthResource();

        return array();
    });
*/

/*
$c['routes'] = array(
    // roue =>
    '/auth/:param1' => array(
        'controller_name' => 'Zenya\Api\Fixtures\AuthResource',
        'controller_args' => array('arg1'=>'value1', 'arg2'=>'string')
    ),

);
*/
// 'AuthResource' => array(
//     'controller_name' => 'Zenya\Api\Fixtures\AuthResource',
//     'controller_args' => array('arg1'=>'value1', 'arg2'=>'string')
// ),

///////////////////////////////////////////////////////////////
// Anything below that point should not need to be modified. //
///////////////////////////////////////////////////////////////

$c['config_path'] = __DIR__;

return $c;